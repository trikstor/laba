#include "KMP_func.h"
#include <iostream>

using namespace std;

/* Печать индексов вхождений.*/
void print(int *result, int size)
{
	for (int i = 0; i < size; i++)
	{
		cout << "Найдено совпадение c индекса " << result[i] << endl;
	}
}

/* Префикс-функция.*/
void prefix(char *mass, int *prfx, int n) 
{
    prfx[0] = 0;									           // Префикс-функция от нулевого индекса всегда 0.

    for(int i = 1; i < n; i++){						           // Перебираем элементы массива.
        int n = prfx[i - 1];						           // Префикс равен предыдущему префиксу.

        while(n > 0 && mass[i] != mass[n])			           // Сравниваем элемент исходного массива с элементом от префикса.
            n = prfx[n - 1];								   // Получаем изначальный префикс, когда элементы строки не были равны друг другу.

        if(mass[i] == mass[n])						           // Если элементы совпали - то увеличиваем префикс на 1.
            n++;

		// Если этот элемент продолжает следование, то увеличиваем префикс, иначе оставляем то же значение префикса.
		prfx[i] = n;
    }
}

/* Поиск Кнута-Морриса-Пратта (КМП). Поиск подстроки в строке. */
int kmp_search(char *mass, char *templa, int *prfx, int *result, int mass_l, int templa_l)
{
	int i = 0;						   							// Счетчик для цикла сравнения строки и шаблона.
	int indent = 0;												// Перемещение по строке.
	int step = 0;												// Шаг, на расстоянии которого будет производиться следующий цикл сравнений.
	int sgn = 0;												// Если в текущем цикле сравнений произошло несовпадение, тогда sgn = 1.
	int count = 0;												// Счетчик кол-ва вхождений шаблона в строку.
	int match = 0;												// Сколько элементов совпало в цикле сравнений.


	while (indent < mass_l)										// Пока не будет достинут конец массива строки.
	{
		for (i = 0; i < templa_l; i++)							// Цикл сравнений шаблона и участка строки.
		{
																// Если не было несовпадений в цикле сравнений и на текущем индексе несовпедние, то sgn = 1;
			if (mass[i + indent + step] != templa[i] && sgn == 0)
				sgn = 1;
			else if(mass[i + indent + step] == templa[i])		 // Если есть совпадение.
			{
				match++;										 // Подсчитываем кол-во совпадений.

				if (i == templa_l-1 && sgn == 0)				 // Если это последнее сравнение в цикле сравнений и оно совпало.
				{
					result[count] = indent + step;				 // Записываем индекс начала цикла сравнений в результирующий массив.
					count++;									 // Подсчитываем кол-во вхождений.
				}
			}
		}


		if (sgn == 0)											 // Если полное совпадение участка строки и шаблона.
		{
			/* Производится сдвиг на всю длину шаблона, 
			учитывая indent увеличение расстояния от начала строки. */
			step = templa_l-1;

			if (mass[step + 1] == templa[0]) // Если после шага начинается совпадение.
				/* Дополнительный сдвиг не производится, так как необходимо 
				проверить возможное совпадение, начиная со следующего элемента строки. */
				step = 0; 
		}
		else													// Если участок строки и шаблон не совпали, либо совпали частично.
		{
			/* Из кол-ва совпавших с шаблоном элементов строки вычитается префикс-функция
			от этого кол-ва и учитывается indent увеличение расстояние от начала строки. */
			step = match - prfx[match] - 1;

			if (step < 0)
				step++;
		}
		match = 0;												 // Обнуляем счетчики.
		sgn = 0;

		indent++;												 // Увеличиваем на 1 расстояние от начала строки.
	}

	return count;												 // Возвращаем кол-во совпадений шаблона со строкой.
}