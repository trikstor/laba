#include <iostream>
#include <ctime>
#include <clocale>
#include "sorting_func.h"

using namespace std;

/* Заполнение массива случайными числами. */
void rand_mass(int *mass, int n)
{
	for(int i = 0; i < n; i++)
	{
		mass[i] = rand() % 10;
	}
}

/* Печать массива */
void print_mass(int *mass, int n)
{
		for(int i = 0; i < n; i++)
		{
			cout << " | " << mass[i];
		}
}

/* Поменять местами i-ый элемент массива, и следующий за ним. */
void change(int *mass, int i, int step)
{
	mass[i] ^= mass[i+step];							// 0+1 = 1; a = 1
	mass[i+step] ^= mass[i];							// 1+1 = 0; b = 0
	mass[i] ^= mass[i+step];							// 1+0 = 1; a = 1
}

/* Рекурсия для функции quicksort. Вызываем сортировку слева/справа, 
если в этих частях есть неупорядоченные элементы массива. */
void recursion(int *mass, int left, int right, int l, int r)
{
		if (l < right){
			quicksort(mass, l+right, l, right);			// l+right - сумма для последующего вычисленеия среднего арифметического.
		}
		if (left < r){
			quicksort(mass, left+r, left, r);			// left+r - сумма для последующего вычисленеия среднего арифметического.
		}
}

/* Быстрая сортировка. 
Вычисляется опорный элемент.
В начале алгоритма 2 переменные l и r указывают, на левый/правый конец массива.
Будем двигать l с шагом в 1 элемент к концу массива, пока l >= опорного эленмента. 
Сдвигаем r от конца к началу массива, пока r <= опорного элемента.
Если l <= r, меняем соответствующие элементы массива местами и повторяем, пока l <= r. */
void quicksort(int *mass, int sr, int left, int right)
{
	/* Опорный элемент равен среднему арифметическому указателей левого и правого края left и right соответственно.*/
	int middle = sr>>1;
		int l = left;									// Новые переменные для сдвига их друг к другу.
		int r = right;

		 while (l <= r)									// Пока левое подмножество меньше либо равно правому.
		 {
			while(mass[l] < mass[middle]) l++;			// Подсчет всех элементов массива с левой части, меньше опорного элемента.
			while(mass[r] > mass[middle]) r--;			// Подсчет всех элементов массива с правой части, больше опорного эленмента.

			/* Если края не пересеклись, то меняем местами элементы массива и изменяем переменные l и r, чтобы не было зацикливания.*/
				if(l < r)
					change(mass, l, r-l);				// Меняем местами элеменгты массива с индексами l и r.

			if (l <= r)									// Проверка, чтобы l и r не перешли за границы массива.
			{
				l++;
				r--;
			}
		}
		 recursion(mass, left, right, l, r);			// Вызываем функцию для рекурсии.
}
