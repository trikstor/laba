#pragma once
#include <iostream>
#include "common_func.h"

using namespace std;

// Односвязный список для работы со стеком
template <typename T>
struct point_S
{
	T* key;														// Указатель на содержание элемента списка

	point_S<T> *next;											// Указатель на следующий элемент списка
};


// ---------------------------------------------------------
// Создание корневого элемента списка (инициализация)
template <typename T>
point_S<T>* make_point_S(T key)
{
	point_S<T> *first;
	point_S<T> *p;

	// Для записи значения в указатель создается динамический массив из одного элемента
	T *temp = new T(1);										   
	temp[0] = key;											   // Ему присваивается ключевое значение

	first = NULL;											   // Указатель на следующий элемент списка равен NULL

	p = new(point_S<T>);									   // Создать корневой элемент списка

	p->key = temp;											   // Указатель на ключевой элемент

	p->next = first;										   // Присваивание соответствующих значений

	delete first;


	return p;												   // Возвращает последний элемент
}
// Перегруженная функция для работы с массивом
template <typename T>
point_S<T>* make_point_S(T *key)
{
	point_S<T> *first;
	point_S<T> *p;

	first = NULL;												// Указатель на следующий и предыдущий элементы списка равны NULL

	p = new(point_S<T>);										// Создать корневой элемент списка

	p->key = key;												// Указатель на ключевой элемент

	p->next = first;											// Присваивание соответствующих значений

	delete first;
	return p;													// Возвращает последний элемент
}
// ---------------------------------------------------------

// ---------------------------------------------------------
//вставка элемента в двунаправленный список
template <typename T>
point_S<T>* insert_elem_S(point_S<T> *p, T item)
{
	point_S<T> *new_item = new(point_S<T>);						// Создание нового элемента списка

	// Для записи значения в указатель создается динамический массив из одного элемента
	T *temp = new T(1);											
	temp[0] = item;												// Ему присваивается ключевое значение

	new_item->key = temp;									    // Присваивание значения элементу списка
	new_item->next = p;                                         // Предыдующий элемент равен новому


	p = new_item;												// Текущий элемент равен новому


	return p;													// Возвращает последний элемент
}
// Перегруженная функция для работы с массивом
template <typename T>
point_S<T>* insert_elem_S(point_S<T> *p, T *item)
{
	point_S<T> *new_item = new(point_S<T>);						// Создание нового элемента списка


	new_item->key = item;										// Присваивание значения элемента списка

	new_item->next = p;											// Предыдующий элемент равен новому

	p = new_item;											    // Текущий элемент равен новому


	return p;													// Возвращает последний элемент
}
// ---------------------------------------------------------

// Удаление элемента списка
template <typename T>
point_S<T>* delete_point_S(point_S<T> *list)
{
	point_S<T> *list1 = list;


	list = list->next;

	delete list1;


	return list;												// Возвращает корневой элемент
}

// ---------------------------------------------------------
// Печать списка
template <typename T>
void listprint_S(point_S<T> *p)
{
	// Временная структура для сохранения указателя на последний элемент в списке
	point_S<T> *temp = p;


	if (temp == NULL)											// Если список не существует, то выводим соответствующее сообщение
		cout << "Список пуст.";
	else {
		while (temp != NULL)									// Перебор всех элементов списка до конца
		{
			// Вывод элемента ключевого поля структуры, заданного как динамический массив из одного элемента
			cout << temp->key[0] << " ";


			temp = temp->next;								    // Следующий элемент списка
		}
	}
	cout << endl;


	delete temp;												// Удаление временной струкуры
}
// Перегруженная функция для работы с массивом
template <typename T>
void listprint_S(point_S<T> *p, int flag)
{
	// Временная структура для сохранения указателя на последний элемент в списке
	point_S<T> *temp = p;


	if (temp == NULL)										   // Если список не существует, то выводим соответствующее сообщение
		cout << "Список пуст.";
	else {
		while (temp != NULL)								   // Перебор всех элементов списка до конца
		{
			for (int i = 0; i < strlen(temp->key); i++)		   // Вывод массива ключевого значения структуры в консоль
				cout << temp->key[i];


			cout << endl;

			temp = temp->next;								   // Следующий элемент списка
		}
	}
	cout << endl;


	delete temp;											   // Удаление временной струкуры
}
// ---------------------------------------------------------

// Удалить заданное кол-во элементов списка
template <typename T>
point_S<T> *delete_elem_S(point_S<T> *p, int quantity)
{
	int i = 0;													// Счетчик удаленных элементов

	// Пока не будет удалено нужное кол-во элементов и не закончится список
	while (i < quantity && p != NULL)
	{
		p = delete_point_S<T>(p);								// Удаление элемента списка


		i++;													// Увеличение счетчика удаленных элементов списка
	}


	return p;													// Возвращает указатель на конец списка
}
// ---------------------------------------------------------

// ---------------------------------------------------------
// Заполнение списка элементами
template <typename T>
point_S<T> *fill_Stack(point_S<T> *list, int quantity)
{
	T in_val;														// Элемент, введенный пользователем
	int counter = 0;												// Счетчик кол-ва введенных элементов


	while (counter < quantity - 1)									// Пока кол-во введенных элементов меньше заданного
	{
		in_val = scan_elem<T>();									// Получаем элемент от пользователя

		list = insert_elem_S<T>(list, in_val);						// Запись элемента в стек


		counter++;													// Увеличение счетчика кол-ва введенных элементов
	}


	return list;													// Возвращает указатель на конец списка
}
// Перегруженная функция для работы с массивом
template <typename T>
point_S<T> *fill_Stack(point_S<T> *list, int quantity, int flag)
{
	int counter = 0;												// Счетчик кол-ва введенных элементов


	while (counter < quantity - 1)									// Пока кол-во введенных элементов меньше заданного
	{
		T *str = new T(255);										// Создаем новый динамический массив
		str = scan_elem<T>(str);									// Получаем массив от пользователя


		list = insert_elem_S<T>(list, str);							// Запись элемента в стек


		counter++;													// Увеличение счетчика кол-ва введенных элементов
	}
	return list;													// Возвращает указатель на конец списка
}
// ---------------------------------------------------------

// ---------------------------------------------------------
// Основная функция работы со списком (создание, удаление элементов, вывод)
template <typename T>
bool Stack(point_S<T> *list, point_S<T> *root)
{
	int counter = 0;												// Кол-во элементов в списке
	int del_q = 0;													// Кол-во удаляемых элементов из списка
	T in_val = NULL;												// Корневой элемент списка


	for_input_params<T> *help_struct = new(for_input_params<T>);	// Вспомогательная структура
	input_params<T>(help_struct);									// Пользовательские параметры записываются функцией в структуру

	counter = help_struct->counter;									// Извлечение пользовательских данных, заданных из структуры
	del_q = help_struct->del_q;
	in_val = help_struct->in_val;

	if (counter == 0 || del_q == 0 || del_q > counter)				// При некоррнектных данных, заданных пользователем
		return false;												// Выход из функции

	list = make_point_S<T>(in_val);									// Создание корневого элемента списка
	root = list;													// Сохранение корня списка


	list = fill_Stack<T>(list, counter);							// Заполнение стека

	list = delete_elem_S<T>(list, del_q);							// Удаление заданного кол-ва элементов

	listprint_S<T>(list);											// Печать списка в консоль


	delete help_struct;												// Удаление вспомогательной структуры

	return true;													// Если все нормально - возвращает true
}
// Перегруженная функция для работы с массивом
template <typename T>
bool Stack(point_S<T> *list, point_S<T> *root, T *str)
{
	int counter = 0;												// Кол-во элементов в списке
	int del_q = 0;													// Кол-во удаляемых элементов из списка

	for_input_params<T> *help_struct = new(for_input_params<T>);	// Вспомогательная структура
	str = input_params<T>(help_struct, str);						// Пользовательские параметры записываются функцией в структуру

	counter = help_struct->counter;									// Извлечение пользовательских данных, заданных из структуры
	del_q = help_struct->del_q;

	if (counter == 0 || del_q == 0 || del_q > counter)				// При некоррнектных данных, заданных пользователем
		return false;

	list = make_point_S<T>(str);									// Создание корневого элемента списка
	root = list;													// Сохранение корня списка

	list = fill_Stack<T>(list, counter, 1);							// Заполнение стека

	list = delete_elem_S<T>(list, del_q);							// Удаление заданного кол-ва элементов

	listprint_S<T>(list, 1);										// Печать списка в консоль


	delete help_struct;												// Удаление вспомагательной структуры

	return true;													// Если все нормально - возвращает true
}
// ---------------------------------------------------------

// ---------------------------------------------------------
// Функция создает структуры для работы со списком и вызывает основную функцию работы со списком
template <typename T>
void Start_Stack()
{
	point_S<T> *list = 0;											// Структуры для конца списка и корня списка
	point_S<T> *root = 0;
	// Флаг для завершения работы программы при неверных пользовательских данных
	bool flag;

	flag = Stack<T>(list, root);									// Вызов основной функции для работы со списком

	delete list;													// Удаление динамических структур
	delete root;
}

// Функция для работы с массивом
template <typename T>
void Start_Stack_mass()
{
	point_S<T> *list = 0;											// Структуры для конца списка и корня списка
	point_S<T> *root = 0;
	T *str = new T(255);											// Массив данных, задаваемых пользователем
	// Флаг для завершения работы программы при неверных пользовательских данных
	bool flag;

	flag = Stack<T>(list, root, str);								// Вызов основной функции для работы со списком

	delete list;													// Удаление динамических структур
	delete root;
}
// ---------------------------------------------------------